# 안티그래비티 백엔드 기술과제

## [피팅노트 서비스에 "가격산정" 기능을 구현 해주세요!]

## 개요

- 이커머스 서비스는 판매촉진을 위해 다양한 상품가격 전략을 전개합니다.
- 정상가, 판매가로 이루어진 기본 골격에 더해 기간별 스팟할인, 쿠폰, 포인트 등 다양한 가격설정을 진행합니다.
- 우리는 이중에서 가장 흔하게 사용되는 _**쿠폰**_에 대해서 작성해보려 합니다.

## 요구사항

- 하나의 상품에 쿠폰과 할인코드를 적용하여 가격을 조회 합니다.
- 상품 가격 조회 api를 완성해주세요.

## 참고사항

- 상품과 프로모션 정보의 스키마와 데이터가 제공됩니다.
- promotion 테이블에는 `COUPON` 과 `CODE` 타입을 가지고있습니다.
    - `COUPON` = 금액할인,
    - `CODE` = %할인으로 계산합니다.
    - promotion 할인 금액을 계산 할때는 상품 기존 가격에 대해 계산 해주시면 됩니다.
- promotion_products 테이블에는 각 promotion에 적용 될 상품들의 매핑정보 입니다.

## 제약사항

- controller request 객체에 parameter는 그대로 사용 해주세요.
    - 상품 1의 프로모션 2가지 적용
- 결과는 ProductAmountResponse 객체를 리턴 해주세요. _주석참고_
- 쿠폰이 적용되는지 검증 로직이 있어야 합니다.
- 촘촘한 검증 코드가 요구됩니다.

## 도메인 로직

- 최소 상품가격은 ₩ 10,000 입니다.
- 최대 상품가격은 ₩ 10,000,000 입니다.
- 최종 상품 금액은 천단위 절삭합니다.

## 기타

- 자유롭게 라이브러리를 추가 하거나 소스 코드를 수정할 수 있습니다.
- 중복 코드 최소화를 고려해주세요.

---

# 안티그래비티 과제 설계안 및 설명

## 비지니스

### 설계안
- 기본 패키지 구조
  - 기존에 잡혀있던 Controller - Service - Repository 서비스 레이어 유지 
    - Controller : 클라이언트가 호출하는 API 라우터 
    - Service : 기능의 전체적인 비지니스 로직
    - Repository : 데이터베이스와 연동하여 데이터를 쿼리하는 작업
- 비지니스 로직 작성 방안
  - 순서
    - 작성된 테스트 코드를 기반으로, 작은 범위의 기능 메소드부터 작성
  - 방안
    - Controller
      - API 정보를 명시 (endpoint, method, request, response 등)
      - 적절한 서비스의 기능을 호출
      - 기타 기본적인 파라미터 검증은 @Valid 어노테이션을 활용하여 검증
      - 각종 인증 인가 검증 기능 (필터 활용)
    - Service
      - API Router, Database Query 기능을 제외한 모든 비지니스 로직을 작성
      - 최소한의 기능 범위로 작성
    - Repository
      - Database Query 기능을 작성
- 기타 안내사항
  - PromotionType Enum 클래스 위치 패키지를 추후 확장된 서비스에서는 이동하는 것을 고려
  - 각종 Exception 정보들은 순수 메세지 생성 방안과 코드 기반의 메세지 매핑 방안을 고려
  - Exception 클라이언트 응답 핸들러 구성 고려

### 코드 작성 근거
- System.out.println() 코드 로깅 이유
  - 불필요한 코드라면 제거하는게 맞고, 시스템 구조상 출력이 필요한 데이터는 각종 포맷팅 기능과 로그 레벨 관리를 위해 로깅으로 구성하는 것이 좋다고 판단
  - 로깅으로 구성을 하면, 배포 서비스에 맞춰 적절한 로그레벨 조절로 로그의 양을 조정할 수 있어 장애 추적이 용이
- couponIds 변수 명 변경 이유
  - 설계안과 도메인명도 프로모션과 혼재되서 사용되고 있고, 프로모션 타입에 쿠폰 타입이 정확히 명시되어 있으니 하나로 통일하는 것이 좋다고 판단

## 테스트 코드

### 설계안
- 기본 패키지 구조
  - Controller, Service, Repository 레이어를 기준으로 테스트코드 작성
- 테스크 코드 작성 방안
  - 순서
    - 테스트 코드를 먼저 작성한 후, 검증할 비지니스 로직을 메소드 범위로 작성하고 최종 서비스 레이어에서 기능 설계에 따라 메소드 호출부를 작성
  - 방안 (개인적 선호 방안)
    - 테스트 이름을 DisplayName 어노테이션으로 상세히 명시 
    - Controller
      - RestAssured 클래스를 활용하여 케이스별 여러 호출 방식 별 응답 데이터를 비교
      - HTTP.ok 를 비롯한 각종 예외 케이스를 상세하게 테스트
    - Service
      - 작은 비지니스 로직부터 작성하고, 먼저 작성된 비지니스 로직을 사용하는 다음 로직 순으로 작성
      - 순수 기능만 검증할 땐, Mock 기반의 테스트 코드로 작성
      - Repository 레이어 결과에 따른 기능을 검증할 땐, SpringBootTest 기반의 테스트 코드를 작성
      - 기능 설계에 따라 성공 케이스와 실패 케이스의 테스트 코드를 모두 작성
    - Repository
      - 데이터베이스 쿼리의 최소 검증 작업을 작성
- 기타 안내사항
  - 과제 방식 특성 상, 파라미터 등이 내부 로직에서 생성되어 사용되기 때문에 Controller 테스트 코드는 생략

### 코드 작성 근거
1. GenerateParam 클래스 생성 이유
   1. 파라미터 생성 메소드는 기능 범위로 여러 테스트에서 사용하기 때문에 생성 전용 클래스를 만들어 static 메소드로 관리
2. Repository 테스트 코드 작성 방식 이유
   1. 실 비지니스 Repository 레이어에서 데이터 조회시 존재 여부에 따른 Exception을 처리하고, 테스트 코드에서는 Exception 기반의 테스트를 하며 실제 비지니스 로직에서는 설계 방식에 따라 적절한 응답으로 조합하여 데이터 응답
      1. 해당 과제는 응답 데이터가 정해져 있어, 따로 조합처리는 없이 예외를 내도록 구성
      2. 개인적으로 선호하는 방식은, 적절한 ExceptionHandler 클래스를 구성하여 ErrorStatusResponse 객체를 구성하여 에러 코드와 합께 사용자에게 노출할 에러 메세지 등을 응답
3. Service 패키지를 세분화하여 구분한 이유
   1. 순수하게 비지니스 로직만 검증하는 테스트코드와 Repository 결과를 통한 비지니스 로직의 검증을 구분하기 위함
   2. 후자의 경우에는 데이터베이스 로직이 포함되기에 따로 묶어서 관리하면 관리가 용이
   3. 그외에 순수 로직들도 로직 특징별로 구분하면 추후에 기능 수정이 있을때, 수정되는 범위에 대한 테스트 실행을 좀더 엄격하게 진행할 수 있음

